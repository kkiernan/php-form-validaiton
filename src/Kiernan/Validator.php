<?php namespace Kiernan;

use BadMethodCallException;

class Validator {

	/**
	 * The data to be validated.
	 * 
	 * @var array
	 */
	protected $data;

	/**
	 * The validation rules.
	 * 
	 * @var array
	 */
	protected $rules;

	/**
	 * Error messages generated by failed rules.
	 * 
	 * @var array
	 */
	protected $messages;

	/**
	 * Default error messages.
	 * 
	 * @var array
	 */
	protected $errors = [
		'required' => 'The :attribute field is required.',
		'boolean' => 'The :attribute field must be true or false.',
		'email' => 'The :attribute field must be an email address.',
		'url' => 'The :attribute field must be a URL.',
		'ip' => 'The :attribute field must be an ip address.',
	];

	/**
	 * Create a new validator instance.
	 * 
	 * @param array $data
	 * @param array $rules
	 */
	public function __construct(array $data, array $rules)
	{
		$this->data = $data;
		$this->rules = $this->parseRules($rules);
	}

	/**
	 * Determine if the data passes validation.
	 * 
	 * @return boolean
	 */
	public function passes()
	{
		foreach ($this->rules as $attribute => $rules)
		{
			foreach ($rules as $rule)
			{
				$this->validate($attribute, $rule);
			}
		}

		return count($this->messages) === 0;
	}

	/**
	 * Determine if the data fails validation.
	 * 
	 * @return boolean
	 */
	public function fails()
	{
		return ! $this->passes();
	}

	/**
	 * Get the messages.
	 * 
	 * @return array
	 */
	public function messages()
	{
		return $this->messages;
	}

	/**
	 * Structure the rules as a nested array.
	 * 
	 * @param  array $rules
	 * @return void
	 */
	protected function parseRules($rules)
	{
		foreach ($rules as &$rule)
		{
			$rule = explode('|', $rule);
		}

		return $rules;
	}

	/**
	 * Call the appropriate validation method if it is validatable.
	 * 
	 * @param  string $attribute
	 * @param  string $rule
	 * @return void
	 */
	protected function validate($attribute, $rule)
	{
		$method = 'validate' . ucfirst($rule);

		$value = $this->getValue($attribute);

		$validatable = $this->isValidatable($rule, $attribute, $value);

		if ($validatable && ! $this->$method($attribute, $value))
		{
			$this->messages[] = $this->getError($rule, $attribute);
		}
	}

	/**
	 * Determine if a validation rule should be run. The rule only needs to
	 * be run if the rule is 'required' or if a value was entered.
	 * 
	 * @param  string  $rule
	 * @param  string  $attribute
	 * @param  string  $value
	 * @return boolean
	 */
	protected function isValidatable($rule, $attribute, $value)
	{
		if ($rule === 'required' || ! empty($value))
		{
			return true;
		}

		return false;
	}

	/**
	 * Get the error message for the failed validation rule.
	 * 
	 * @param  string $rule
	 * @param  string $attribute
	 * @return string
	 */
	protected function getError($rule, $attribute)
	{
		$error = $this->errors[$rule];

		return $this->replaceAttribute($error, $attribute);
	}

	/**
	 * Replace the :attribute tag with the attribute name.
	 * 
	 * @param  string $error
	 * @param  string $attribute
	 * @return void
	 */
	public function replaceAttribute($error, $attribute)
	{
		return str_replace(':attribute', $attribute, $error);
	}

	/**
	 * Validate that a required attribute exists.
	 * 
	 * @param  string $attribute
	 * @param  string $value
	 * @return boolean
	 */
	protected function validateRequired($attribute, $value)
	{
		if ( ! array_key_exists($attribute, $this->data))
		{
			return false;
		}
		else if (trim($value) === '')
		{
			return false;
		}

		return true;
	}

	/**
	 * Validate that an attribute is a valid email.
	 * 
	 * @param  string $attribute
	 * @param  string $value
	 * @return boolean
	 */
	protected function validateEmail($attribute, $value)
	{
		return filter_var($value, FILTER_VALIDATE_EMAIL) !== false;
	}

	/**
	 * Validate that an attribute is a boolean.
	 * 
	 * @param  string $attribute
	 * @param  string $value
	 * @return boolean
	 */
	protected function validateBoolean($attribute, $value)
	{
		return filter_var($value, FILTER_VALIDATE_BOOLEAN) !== false;
	}

	/**
	 * Validate that an attribute is a url.
	 * 
	 * @param  string $attribute
	 * @param  string $value
	 * @return boolean
	 */
	protected function validateUrl($attribute, $value)
	{
		return filter_var($value, FILTER_VALIDATE_URL) !== false;
	}

	/**
	 * Validate that an attribute is an ip address.
	 * 
	 * @param  string $attribute
	 * @param  string $value
	 * @return boolean
	 */
	protected function validateIp($attribute, $value, $flags = null)
	{
		return filter_var($value, FILTER_VALIDATE_IP, $flags) !== false;
	}

	/**
	 * Get the value for an attribute in the data array.
	 * 
	 * @param  string $attribute
	 * @return string|null
	 */
	protected function getValue($attribute)
	{
		if ( ! array_key_exists($attribute, $this->data))
		{
			return null;
		}

		return $this->data[$attribute];
	}

	/**
	 * Throw an exception if an undefined method is called.
	 * 
	 * @param  string $method
	 * @param  string $parameters
	 * @return void
	 */
	public function __call($method, $parameters)
	{
		throw new BadMethodCallException("Method $method does not exist.");
	}

}
